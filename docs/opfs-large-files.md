# Service Worker для огромных файлов через файловую систему (OPFS)

Документ фиксирует обсуждённую архитектуру и сценарии для плагинов SW, которые кешируют большие файлы в OPFS и отдают их по диапазонам без последовательного чтения.

---

## 1. Проблема Cache API

- **Cache API** отдаёт тело закешированного ответа как **поток (stream)** — только последовательное чтение, без произвольного доступа (seek).
- Чтобы отдать диапазон в конце большого файла, SW вынужден **читать поток с начала** до нужной позиции → время растёт с размером файла (секунды и десятки секунд для гигабайтных файлов).
- На **сервере** и в **файловой системе** устройства есть произвольный доступ (seek + read) — там такой проблемы нет.
- **Итог:** для больших файлов кеш в Cache API даёт медленный доступ к концу; при наличии сети сервер часто отдаёт быстрее. Офлайн и повторные запросы выигрывают за счёт кеширования ответов 206 (повторный запрос того же диапазона — из кеша).

---

## 2. Решение: OPFS (Origin Private File System)

- **OPFS** — файловая система на origin, доступна в воркерах (в т.ч. Service Worker).
- Файл в OPFS можно читать по диапазону через **`File` + `file.slice(start, end)`** — без загрузки всего файла в память и без последовательного прогона. Доступ к концу файла быстрый.
- **Ограничение:** `FileSystemSyncAccessHandle` (низкоуровневый seek/read) доступен только в **dedicated Web Worker**, не в Service Worker. В SW используем асинхронный путь: `fileHandle.getFile()` → `file.slice(start, end)` → Blob диапазона.
- **Поддержка OPFS:** ~92% глобально (Chrome 108+, Edge 108+, Firefox 111+, Safari 16.4+, iOS 16.4+ и т.д.), только secure context (HTTPS).

---

## 3. Полный цикл работы

### 3.1 Фаза предкеша (известный список URL)

- При установке SW (или по явному триггеру) плагин получает список URL.
- Для каждого URL: `fetch(url)` → тело ответа **потоком** (`response.body`) → запись в файл в OPFS через `fileHandle.createWritable()` и **pipe** (или цикл read/write), **без** `arrayBuffer()`/`blob()` на весь файл — чтобы не загружать огромный файл в память.
- Сохраняется **индекс:** URL → ключ файла в OPFS, размер, ETag, Last-Modified (для If-Range). Индекс — в OPFS (отдельный файл) или в Cache API (только метаданные).

### 3.2 Фаза перехвата fetch и отдачи по диапазонам

- Запрос перехватывается SW. Проверка: URL есть в индексе OPFS?
- Если нет — запрос уходит дальше (сеть / другой плагин).
- Если да — опционально проверка **If-Range** (ETag/Last-Modified из индекса); при несовпадении — не отдаём из кеша, передаём запрос дальше.
- Парсинг заголовка **Range** → один диапазон `[start, end]`.
- В OPFS: `getFileHandle(key)` → `fileHandle.getFile()` → `file.slice(start, end)` → Blob.
- Ответ: **206**, заголовки `Content-Range`, `Accept-Ranges: bytes`, `Content-Length`, при необходимости `Content-Type`, `Cache-Control`, ETag/Last-Modified.
- Тело: `new Response(blob, { headers })`. Доступ к концу файла быстрый (slice без последовательного чтения).

### 3.3 Динамическое кеширование (без предкеша)

- Запрос уходит в сеть; при успешном ответе плагин по правилам (glob, размер, путь) решает: кешировать в OPFS.
- Тело ответа **потоком** пишется в OPFS (pipe, без загрузки всего в память); обновляется индекс.
- Клиент получает ответ (можно через tee потока или после записи — по архитектуре). При следующих запросах тот же URL обслуживается из OPFS плагином диапазонов.

---

## 4. Плагины и их обязанности

| Плагин | Назначение | Основные действия |
|--------|------------|-------------------|
| **Предкеш в OPFS** | Сохранить известный список больших файлов в файловую систему при установке/по триггеру | Список URL (манифест/конфиг) → fetch → потоковая запись в OPFS → индекс. Квоты, вытеснение, ошибки. |
| **Динамический кеш в OPFS** | При первом запросе по сети — сохранить подходящие ответы в OPFS | Перехват fetch → сеть → по правилам (тип, размер, путь) → потоковая запись в OPFS + индекс. Клиент получает ответ; следующий раз — из OPFS. |
| **Отдача по диапазонам из OPFS** | Быстрая отдача 206 из OPFS по Range | Перехват fetch → индекс → If-Range (опционально) → getFile → slice(start, end) → 206. При отсутствии в индексе / несовпадении валидатора — передать дальше. |

Общий **индекс** (URL ↔ файл в OPFS + метаданные) единый; оба кеширующих плагина его заполняют, плагин диапазонов — читает.

---

## 5. Как задать, какие файлы кешировать в OPFS

- **Явный список при регистрации SW / в конфиге плагина:** `opfsUrls: ['/media/film1.mp4', ...]` — предкеш при install.
- **Секция в precache-манифесте:** например `opfs: [...]` — отдельно от обычного Cache API precache.
- **Правила по паттерну/размеру:** glob (`**/*.mp4`), или «в OPFS — ответы больше N МБ» — для динамического кеша.
- **postMessage с клиента:** `{ type: 'CACHE_TO_OPFS', url: '...' }` — добавление в OPFS по действию пользователя («скачать для офлайна»).

---

## 6. Потоковая запись — обязательно

- Сервер отдаёт большой файл **потоком** (буфер на сервере небольшой).
- На клиенте **не** использовать `response.arrayBuffer()` / `response.blob()` для огромного файла — риск OOM.
- Нужно: **response.body (ReadableStream)** → **pipeTo(writable)** или цикл read/write в `fileHandle.createWritable()` — в памяти только буфер чанков (например, 64–256 КБ).

---

## 7. Сравнение с онлайн и Cache API

- **Онлайн:** сервер отдаёт по Range с seek; быстро, но нужна сеть и трафик.
- **Cache API (текущий psw-plugin-serve-range-requests):** корректная 206 из кеша, но последовательное чтение → медленный доступ к концу большого файла; при сети иногда проигрываем по скорости. Повторные запросы того же диапазона — быстрые (кеш 206).
- **OPFS:** кеш в файловой системе, отдача через getFile + slice → быстрый доступ к любой позиции, в т.ч. конец файла; офлайн и экономия трафика при повторных просмотрах. Нет «указателя на файл» для страницы — только перехват fetch и ответ из SW (так устроена платформа).

---

## 8. Что проверить при реализации

- [ ] Поддержка `getFile()` и `file.slice()` для файлов в OPFS в **Service Worker** в целевых браузерах (в т.ч. мобильные).
- [ ] Формат индекса (URL → key, size, etag, lastModified), хранение в OPFS или Cache API.
- [ ] Квота OPFS, обработка переполнения, вытеснение (например, LRU по дате/размеру).
- [ ] Согласование с существующей стратегией кеширования (Cache API vs OPFS по URL/правилам).
- [ ] If-Range при отдаче из OPFS (валидаторы из индекса).
- [ ] Обработка ошибок записи/чтения, отмена записи при отмене fetch.

---

## 9. Сценарий установки: не грузить огромные файлы при install

**Проблема:** При первой загрузке приложения в кеш SW логично класть только ресурсы, связанные с приложением (оболочка: HTML, JS, CSS, иконки, манифест). Если при установке SW начать загружать огромный файл (например, векторные карты), пользователь может не дождаться окончания загрузки, закрыть браузер и уйти. Загрузка оборвётся, кеш останется неполным, установка SW может надолго затянуться.

**Идея:** При установке SW кешировать только то, что нужно для быстрого старта приложения (лёгкие ресурсы). Огромные файлы в фазу install **не включать**.

**Большие файлы — отдельная стратегия:**

1. **По первому использованию** — когда пользователь впервые открывает карту/медиа, делаем fetch; тогда сохраняем ответ в OPFS (или Cache), пока идёт использование. Либо не предзагружаем вообще — «доступно только онлайн».
2. **Явное действие пользователя** — кнопка «Скачать карту для офлайна»: по нажатию запускается загрузка (в фоне через **Background Fetch API** или обычный fetch с индикатором). Пользователь понимает, что идёт загрузка; может дождаться или уйти — при использовании Background Fetch загрузка может продолжиться даже после закрытия вкладки.
3. **Фоновая загрузка после установки** — после успешного `install` SW активируется без ожидания больших файлов; позже (по событию или по сообщению со страницы) запускается загрузка большого файла в OPFS. Приложение уже работает; если загрузка идёт через Background Fetch, она может продолжаться после закрытия страницы.

**Итого:** На этапе install кешируем только оболочку приложения; огромные файлы (карты, видео) загружаем по другой логике — при первом обращении, по кнопке «скачать офлайн» или в фоне после установки. Так пользователь не зависит от долгой загрузки при первом заходе и не уходит с «зависшей» установкой.
